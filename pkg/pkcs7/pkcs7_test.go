package pkcs7

import (
	"bytes"
	"crypto/aes"
	"errors"
	"testing"
	"testing/quick"
)

var testString = []byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, 0xad, 0x15, 0xea, 0x5e, 0xfe, 0xe1, 0xde, 0xad}

var PadTests = []struct {
	in, out []byte
}{
	{
		testString[:0],
		[]byte{0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10},
	},
	{
		testString[:1],
		[]byte{0xde, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f},
	},
	{
		testString[:2],
		[]byte{0xde, 0xad, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e},
	},
	{
		testString[:3],
		[]byte{0xde, 0xad, 0xbe, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d},
	},
	{
		testString[:4],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c},
	},
	{
		testString[:5],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b},
	},
	{
		testString[:6],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a},
	},
	{
		testString[:7],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09},
	},
	{
		testString[:8],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08},
	},
	{
		testString[:9],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, 0xad, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07},
	},
	{
		testString[:10],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, 0xad, 0x15, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06},
	},
	{
		testString[:11],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, 0xad, 0x15, 0xea, 0x05, 0x05, 0x05, 0x05, 0x05},
	},
	{
		testString[:12],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, 0xad, 0x15, 0xea, 0x5e, 0x04, 0x04, 0x04, 0x04},
	},
	{
		testString[:13],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, 0xad, 0x15, 0xea, 0x5e, 0xfe, 0x03, 0x03, 0x03},
	},
	{
		testString[:14],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, 0xad, 0x15, 0xea, 0x5e, 0xfe, 0xe1, 0x02, 0x02},
	},
	{
		testString[:15],
		[]byte{0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, 0xad, 0x15, 0xea, 0x5e, 0xfe, 0xe1, 0xde, 0x01},
	},
	{
		testString,
		[]byte{
			0xde, 0xad, 0xbe, 0xef, 0xba, 0xad, 0xf0, 0x0d, 0xad, 0x15, 0xea, 0x5e, 0xfe, 0xe1, 0xde, 0xad,
			0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
		},
	},
}

func TestPad(t *testing.T) {
	t.Parallel()

	for i, test := range PadTests {
		buf := make([]byte, len(test.in))
		copy(buf, test.in)
		pad, err := Pad(buf, aes.BlockSize)
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(pad, test.out) {
			t.Errorf("%d: %x != %x", i, pad, test.out)
		}
	}
}

func TestUnpad(t *testing.T) {
	t.Parallel()

	for i, test := range PadTests {
		buf := make([]byte, len(test.out))
		copy(buf, test.out)

		unpad, err := Unpad(buf, aes.BlockSize)
		if err != nil {
			t.Errorf("[%d] error unpadding: %v", i, err)
		}
		if !bytes.Equal(unpad, test.in) {
			t.Errorf("[%d] %x != %x", i, unpad, test.in)
		}
	}
}

var BadPadTests = [][]byte{
	{0x04, 0x04, 0x04},
	{0xde, 0xad, 0xbe, 0xef, 0x03, 0x02, 0x03},
	{0xde, 0xad, 0xbe, 0xef, 0x00},
}

func TestUnpadErrors(t *testing.T) {
	t.Parallel()

	for i, test := range BadPadTests {
		_, err := Unpad(test, aes.BlockSize)
		if !errors.Is(err, errInvalidPadding) &&
			!errors.Is(err, errInvalidBlockLen) &&
			!errors.Is(err, errInvalidDataLen) {
			t.Errorf("%d: expected BadCiphertext, got %v", i, err)
		}
	}
}

func completelyUnsafeNotConstantTimeUnpad(buf []byte, blockLen int) ([]byte, error) {
	if blockLen <= 0 {
		return nil, errInvalidBlockLen
	}
	if len(buf)%blockLen != 0 || len(buf) == 0 {
		return nil, errInvalidDataLen
	}
	padLen := buf[len(buf)-1]
	if int(padLen) > len(buf) || padLen == 0 {
		return nil, errInvalidPadding
	}

	out, padding := buf[:len(buf)-int(padLen)], buf[len(buf)-int(padLen):]
	rep := bytes.Repeat([]byte{padLen}, int(padLen))
	if !bytes.Equal(padding, rep) {
		return nil, errInvalidPadding
	}
	return out, nil
}

func TestUnpadBlackBox(t *testing.T) {
	t.Parallel()
	err := quick.CheckEqual(Unpad, completelyUnsafeNotConstantTimeUnpad, nil)
	if err != nil {
		t.Error(err)
	}
}
